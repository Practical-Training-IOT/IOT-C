// Code generated by Kitex v0.13.1. DO NOT EDIT.

package alarm

import (
	"context"
	"errors"
	alarm "github.com/Practical-Training-IOT/IOT-C/kitex_gen/iot/alarm"
	client "github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
)

var errInvalidMessageType = errors.New("invalid message type for service method handler")

var serviceMethods = map[string]kitex.MethodInfo{
	"AlarmList": kitex.NewMethodInfo(
		alarmListHandler,
		newAlarmAlarmListArgs,
		newAlarmAlarmListResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingNone),
	),
	"AlarmDetail": kitex.NewMethodInfo(
		alarmDetailHandler,
		newAlarmAlarmDetailArgs,
		newAlarmAlarmDetailResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingNone),
	),
	"AlarmSearch": kitex.NewMethodInfo(
		alarmSearchHandler,
		newAlarmAlarmSearchArgs,
		newAlarmAlarmSearchResult,
		false,
		kitex.WithStreamingMode(kitex.StreamingNone),
	),
}

var (
	alarmServiceInfo                = NewServiceInfo()
	alarmServiceInfoForClient       = NewServiceInfoForClient()
	alarmServiceInfoForStreamClient = NewServiceInfoForStreamClient()
)

// for server
func serviceInfo() *kitex.ServiceInfo {
	return alarmServiceInfo
}

// for stream client
func serviceInfoForStreamClient() *kitex.ServiceInfo {
	return alarmServiceInfoForStreamClient
}

// for client
func serviceInfoForClient() *kitex.ServiceInfo {
	return alarmServiceInfoForClient
}

// NewServiceInfo creates a new ServiceInfo containing all methods
func NewServiceInfo() *kitex.ServiceInfo {
	return newServiceInfo(false, true, true)
}

// NewServiceInfo creates a new ServiceInfo containing non-streaming methods
func NewServiceInfoForClient() *kitex.ServiceInfo {
	return newServiceInfo(false, false, true)
}
func NewServiceInfoForStreamClient() *kitex.ServiceInfo {
	return newServiceInfo(true, true, false)
}

func newServiceInfo(hasStreaming bool, keepStreamingMethods bool, keepNonStreamingMethods bool) *kitex.ServiceInfo {
	serviceName := "alarm"
	handlerType := (*alarm.Alarm)(nil)
	methods := map[string]kitex.MethodInfo{}
	for name, m := range serviceMethods {
		if m.IsStreaming() && !keepStreamingMethods {
			continue
		}
		if !m.IsStreaming() && !keepNonStreamingMethods {
			continue
		}
		methods[name] = m
	}
	extra := map[string]interface{}{
		"PackageName": "alarm",
	}
	if hasStreaming {
		extra["streaming"] = hasStreaming
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Thrift,
		KiteXGenVersion: "v0.13.1",
		Extra:           extra,
	}
	return svcInfo
}

func alarmListHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	realArg := arg.(*alarm.AlarmAlarmListArgs)
	realResult := result.(*alarm.AlarmAlarmListResult)
	success, err := handler.(alarm.Alarm).AlarmList(ctx, realArg.Req)
	if err != nil {
		return err
	}
	realResult.Success = success
	return nil
}
func newAlarmAlarmListArgs() interface{} {
	return alarm.NewAlarmAlarmListArgs()
}

func newAlarmAlarmListResult() interface{} {
	return alarm.NewAlarmAlarmListResult()
}

func alarmDetailHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	realArg := arg.(*alarm.AlarmAlarmDetailArgs)
	realResult := result.(*alarm.AlarmAlarmDetailResult)
	success, err := handler.(alarm.Alarm).AlarmDetail(ctx, realArg.Req)
	if err != nil {
		return err
	}
	realResult.Success = success
	return nil
}
func newAlarmAlarmDetailArgs() interface{} {
	return alarm.NewAlarmAlarmDetailArgs()
}

func newAlarmAlarmDetailResult() interface{} {
	return alarm.NewAlarmAlarmDetailResult()
}

func alarmSearchHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	realArg := arg.(*alarm.AlarmAlarmSearchArgs)
	realResult := result.(*alarm.AlarmAlarmSearchResult)
	success, err := handler.(alarm.Alarm).AlarmSearch(ctx, realArg.Req)
	if err != nil {
		return err
	}
	realResult.Success = success
	return nil
}
func newAlarmAlarmSearchArgs() interface{} {
	return alarm.NewAlarmAlarmSearchArgs()
}

func newAlarmAlarmSearchResult() interface{} {
	return alarm.NewAlarmAlarmSearchResult()
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) AlarmList(ctx context.Context, req *alarm.AlarmListReq) (r *alarm.AlarmListResp, err error) {
	var _args alarm.AlarmAlarmListArgs
	_args.Req = req
	var _result alarm.AlarmAlarmListResult
	if err = p.c.Call(ctx, "AlarmList", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AlarmDetail(ctx context.Context, req *alarm.AlarmDetailReq) (r *alarm.AlarmDetailResp, err error) {
	var _args alarm.AlarmAlarmDetailArgs
	_args.Req = req
	var _result alarm.AlarmAlarmDetailResult
	if err = p.c.Call(ctx, "AlarmDetail", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AlarmSearch(ctx context.Context, req *alarm.AlarmSearchReq) (r *alarm.AlarmSearchResp, err error) {
	var _args alarm.AlarmAlarmSearchArgs
	_args.Req = req
	var _result alarm.AlarmAlarmSearchResult
	if err = p.c.Call(ctx, "AlarmSearch", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
